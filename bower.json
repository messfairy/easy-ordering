{
  "name": "easing-ordering",
  "devDependencies": {
    "zepto": "*",
    "backbone":"*",
    "backbone.localStorage": "*",
    "iscroll":"*",
    "font-awesome": "*",
    "semantic-ui": "*"
  }
}


换一种维度组织api
从功能模块组织

最常用的api

页面渲染
右键菜单
从headnav开始
left
page board
right
console board

新建 另存为 重命名 刷新 
打开 关闭 全部关闭 关闭其他
头切换 page切换
文件名过滤 捡入状态过滤
编辑 保存 复制 粘贴
捡入检出撤销
删除 查找 搜索
快捷键监听
ide状态保存和恢复
page同步状态

treeview  rttree
file dblclick openPage
click selected
create file
contextmenu

selectTree
openPage
rightmenu
active

同步状态的代码
保存 捡入代码入口
rt缺一份reference文档

跳转为啥那么不稳定？

把提纲提交到cc

跳转
模板的好处
比如修改actionlist tab图标
分层的好处
  没有分层时怎么处理，每一个视图一个打开操作？
  冲突小
类脉络结构 
  Bean Tree
  Event Tree
  View Tree
  FileTree
  PageStore
  PageView
  IDEMirror server
  
  controller负责对外通信
  store数据事务
  
  右键菜单 交互
  快捷键 交互
  builder
  全局api
  bean生命周期api
controller到view，controller是外交部
view和子view之间通信api 利用parent和beans互相调用
controller是中介者模式的应用，基础是依赖注入
内聚好，事务性
交互最多的操作 打开 关闭
右键菜单作为
api化举例
api遵循最小知识原则
API举例
  headnav updateItems
  注入api的增强 支持父类和通配符
  消息api
  PageView parent 
  打开文件 swapdoc
  插件api
API如何暴露范围
事件是反向api

视图划分的哲学
既不能太大也不能太小
解耦要有度
比如如果view之间彻底解耦怎么渲染？
全局api要谨慎
可读性不仅仅体现在从入口跟代码这种走读，而在于我实现某功能应该从哪里下手，修改bug从哪里入手，一看便知
比如，有一个bug，是取状态的一个bug，我只需要修改PageStore的代码就可以了

若干codemirror展示代码，每打开页面刷新代码
PageView
swapdoc

设计可以改进的地方
树控件需要模板
模板可以保存
一个codemirror就够了
不同的类型，编辑和快捷键可能不太一样
设计需要取舍和平衡
PageSet过于扩散
防止这种扩散，无论是全局变量的扩散还是参数的扩散
TreeStore改成组合模式
支持注解ioc
支持注解aop
切换和打开逻辑过于复杂，流程链过长
一般的多层调用都应该控制流程链，到了某个层就把该做的做完

为何要容忍重复代码，不提早优化
插件的api
BeanFactory 注入api的演化
最初只支持按类型注入，只支持单实例，
扩展性差，只能全局注入
后面支持key注入，name注入，可以局部注入
且自动生成属性，this inject

支持父类注入，通配符注入
最初只能通过inject方法注入引用
后面支持先配置实例后reference，
再后面支持被引用时自动实例化，
最后还会支持类似注解的ioc

关闭功能的演化
折叠盒的演化
右键菜单的演化

